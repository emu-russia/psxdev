// Тестовый скрипт для проверки парсера регистровых передач

// Простая передача 

{a, b, c[2], d[5]} = b;

/*

// Операция NOT

x = not (a);

// NOR

x = nor (a, b);

// SUM

{sum,cout} = adder (a, b, cin);

// адресация отдельного разряда

x[3] = not (a[5]);

// вызов сумматора с возвращением результата в 2-разрядную переменную
sum_cout = adder (a, b, cin);


// вызов сумматора с возратом в 1-разрядную переменную
sum = adder (a, b, cin);

// константы

a[3] = 1;


// вложенные регистровые передачи

x[2] = nor ( nand (a,b), c);

// передача результатов сумматора на 2-х входовую ячейку с 1-м выходом

x = nor ( adder (a, b, cin) );

// discard лишние входы

x = nor (a, b, c);

// discard лишние выходы
{x, y} = nor (a, b);


//{ {ident[[bit]], ...} | ident[[bit]] } {=|<=} expr

//lvalue_list EQ rvalue_list


/*

module sum_1 (input wire a_1, input wire b_1, input wire cin_1, output wire sum_1, output wire cout_1);
    block (*) 
    nand / nor ...
endmodule

module sum_2 (input wire a_2, input wire b_2, input wire cin_2, output wire sum_2, output wire cout_2);
    block (*) 
    nand / nor ...
endmodule

module some (input wire in1, input wire in2, input wire CLK);
    wire z1, z2;
    wire sum, cout;
    wire res[2];

    block (CLK) begin
        z1 = nor (in1, in2);
        z2 = nand (in1, in2);
    end

endmodule


wire a, b, c;

a = trans ( b, c );



*/

